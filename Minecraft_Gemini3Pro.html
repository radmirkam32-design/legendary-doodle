<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft: –î–µ—Ä–µ–≤–Ω—è Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Courier New', Courier, monospace; }
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 20px; height: 20px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path d="M10 0v20M0 10h20" stroke="white" stroke-width="2"/></svg>') no-repeat center;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        #info {
            position: absolute;
            top: 10px; left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            pointer-events: none;
            user-select: none;
        }
        #instructions {
            margin-top: 10px;
            font-size: 0.9em;
            color: #ddd;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="info">
        <h3>üå≤ Minecraft: –î–µ—Ä–µ–≤–Ω—è</h3>
        <p>–ù–∞–∂–º–∏ <b>–ö–õ–ò–ö</b> —á—Ç–æ–±—ã –∏–≥—Ä–∞—Ç—å</p>
        <div id="instructions">
            WASD - –•–æ–¥–∏—Ç—å | SPACE - –ü—Ä—ã–∂–æ–∫<br>
            –õ–ö–ú - –õ–æ–º–∞—Ç—å | –ü–ö–ú - –°—Ç–∞–≤–∏—Ç—å<br>
            1 - –î–æ—Å–∫–∏ | 2 - –ë—Ä–µ–≤–Ω–∞ | 3 - –õ–∏—Å—Ç–≤–∞
        </div>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ ---
        let camera, scene, renderer, controls;
        let raycaster;
        const objects = []; 
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        // –ú–∞—Ç–µ—Ä–∏–∞–ª—ã
        const materials = {};
        let currentMaterial = 'plank'; 

        // --- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ–∫—Å—Ç—É—Ä (Pixel Art) ---
        function createTexture(color, type = 'noise') {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 64, 64);
            
            if (type === 'noise') {
                for(let i=0; i<600; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.15})`;
                    ctx.fillRect(Math.random()*64, Math.random()*64, 4, 4);
                }
            } else if (type === 'planks') {
                // –†–∏—Å—É–µ–º –¥–æ—Å–∫–∏
                ctx.fillStyle = "rgba(0,0,0,0.1)";
                for(let i=1; i<4; i++) ctx.fillRect(0, i*16, 64, 2);
                // –®—É–º –¥–µ—Ä–µ–≤–∞
                for(let i=0; i<200; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1})`;
                    ctx.fillRect(Math.random()*64, Math.random()*64, 8, 2);
                }
            } else if (type === 'log') {
                // –ö–æ—Ä–∞ –¥–µ—Ä–µ–≤–∞
                for(let i=0; i<10; i++) {
                     ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.2})`;
                     ctx.fillRect(Math.random()*50, 0, 4, 64);
                }
            }
            
            // –†–∞–º–∫–∞ –±–ª–æ–∫–∞
            ctx.strokeStyle = "rgba(0,0,0,0.1)";
            ctx.lineWidth = 2;
            ctx.strokeRect(0,0,64,64);

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return new THREE.MeshLambertMaterial({ map: tex });
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5); // –°—Ç–∞—Ä—Ç –ø–µ—Ä–µ–¥ –¥–æ–º–æ–º

            // –°–≤–µ—Ç (–°–æ–ª–Ω—Ü–µ)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 80, 30);
            scene.add(dirLight);

            // –°–æ–∑–¥–∞–Ω–∏–µ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ –¥–ª—è –¥–µ—Ä–µ–≤–Ω–∏
            materials.grass = createTexture('#6fa34e', 'noise'); // –¢—Ä–∞–≤–∞
            materials.dirt = createTexture('#5d4037', 'noise');  // –ó–µ–º–ª—è (–≥—Ä—è–¥–∫–∏/–¥–æ—Ä–æ–≥–∏)
            materials.log = createTexture('#3e2723', 'log');    // –ë—Ä–µ–≤–Ω–∞ (—Å—Ä—É–±)
            materials.plank = createTexture('#a1887f', 'planks');// –î–æ—Å–∫–∏ (–ø–æ–ª/–∑–∞–±–æ—Ä)
            materials.leaves = createTexture('#2e7d32', 'noise');// –õ–∏—Å—Ç–≤–∞
            materials.glass = new THREE.MeshLambertMaterial({ color: 0xadd8e6, transparent: true, opacity: 0.6 });
            materials.water = new THREE.MeshLambertMaterial({ color: 0x1a237e, transparent: true, opacity: 0.8 });
            materials.stone = createTexture('#757575', 'noise'); // –î–ª—è –∫–æ–ª–æ–¥—Ü–∞
            materials.carRed = createTexture('#d32f2f', 'noise'); // –ñ–∏–≥—É–ª–∏
            materials.carBlack = createTexture('#212121', 'noise');

            // --- –ì–ï–ù–ï–†–ê–¶–ò–Ø –î–ï–†–ï–í–ù–ò ---
            generateVillage();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);
            
            const blocker = document.getElementById('info');
            document.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => blocker.style.display = 'none');
            controls.addEventListener('unlock', () => blocker.style.display = 'block');
            scene.add(controls.getObject());

            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            const onKeyDown = (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': if (canJump) velocity.y += 15; canJump = false; break;
                    case 'Digit1': currentMaterial = 'plank'; break;
                    case 'Digit2': currentMaterial = 'log'; break;
                    case 'Digit3': currentMaterial = 'leaves'; break;
                }
            };
            const onKeyUp = (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            raycaster = new THREE.Raycaster();
            document.addEventListener('mousedown', onMouseClick);
            window.addEventListener('resize', onWindowResize);
        }

        function onMouseClick(event) {
            if (!controls.isLocked) return;
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                if (event.button === 0) { // –õ–æ–º–∞—Ç—å
                    if(intersect.object.name !== "bedrock") {
                        scene.remove(intersect.object);
                        objects.splice(objects.indexOf(intersect.object), 1);
                    }
                } else if (event.button === 2) { // –°—Ç–∞–≤–∏—Ç—å
                    const voxel = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), materials[currentMaterial]);
                    voxel.position.copy(intersect.point).add(intersect.face.normal).divideScalar(1).floor().multiplyScalar(1).addScalar(0.5);
                    scene.add(voxel);
                    objects.push(voxel);
                }
            }
        }

        // --- –õ–û–ì–ò–ö–ê –ü–û–°–¢–†–û–ô–ö–ò –î–ï–†–ï–í–ù–ò ---
        function generateVillage() {
            // 1. –ó–µ–º–ª—è (–ü–æ–ª–µ)
            for (let x = -25; x < 25; x++) {
                for (let z = -25; z < 25; z++) {
                    let mat = materials.grass;
                    
                    // –¢—Ä–æ–ø–∏–Ω–∫–∏ (–∏–∑–≤–∏–ª–∏—Å—Ç—ã–µ)
                    if (Math.abs(x + Math.sin(z/4)*3) < 2) mat = materials.dirt; 
                    
                    // –ì—Ä—è–¥–∫–∏ (–æ–≥–æ—Ä–æ–¥)
                    if (x > 10 && x < 20 && z > 5 && z < 15) {
                        if (z % 2 === 0) mat = materials.dirt; // –í—Å–ø–∞—Ö–∞–Ω–Ω–∞—è –∑–µ–º–ª—è
                    }

                    addBlock(x, -1, z, mat, "bedrock");
                }
            }

            // 2. –î–µ—Ä–µ–≤–µ–Ω—Å–∫–∏–µ –ò–∑–±—ã (–î–æ–º–∞)
            buildIzba(-8, 0, -8); // –î–æ–º –∏–≥—Ä–æ–∫–∞
            buildIzba(-10, 0, 10); // –î–æ–º —Å–æ—Å–µ–¥–∞
            buildIzba(15, 0, -10); // –î–∞–ª—å–Ω–∏–π –¥–æ–º

            // 3. –ö–æ–ª–æ–¥–µ—Ü (–≤ —Ü–µ–Ω—Ç—Ä–µ)
            buildWell(5, 0, 5);

            // 4. –î–µ—Ä–µ–≤—å—è (–ë–µ—Ä–µ–∑—ã –∏ –¥—É–±—ã)
            for(let i=0; i<15; i++) {
                let rx = Math.floor(Math.random() * 40) - 20;
                let rz = Math.floor(Math.random() * 40) - 20;
                // –ù–µ —Å—Ç–∞–≤–∏–º –Ω–∞ –¥–æ—Ä–æ–≥–µ –∏ –≤ –¥–æ–º–∞—Ö (–ø—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞)
                if (Math.abs(rx) > 5 || Math.abs(rz) > 5) {
                    buildTree(rx, 0, rz);
                }
            }

            // 5. –ó–∞–±–æ—Ä—á–∏–∫–∏
            for(let z=-5; z<5; z++) addBlock(-4, 0, z, materials.plank);

            // 6. –ú–∞—à–∏–Ω–∞ (–ñ–∏–≥—É–ª–∏) —É –¥–æ–º–∞
            buildCar(-2, 0, -5);
        }

        function addBlock(x, y, z, material, name="block") {
            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mesh = new THREE.Mesh(geo, material);
            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            mesh.name = name;
            scene.add(mesh);
            objects.push(mesh);
        }

        // –°—Ç—Ä–æ–∏–º –ò–∑–±—É (–°—Ä—É–±)
        function buildIzba(x, y, z) {
            const w = 5, h = 4, d = 6;
            
            // –°—Ç–µ–Ω—ã
            for(let i=0; i<w; i++) {
                for(let j=0; j<h; j++) {
                    for(let k=0; k<d; k++) {
                        // –¢–æ–ª—å–∫–æ –ø–µ—Ä–∏–º–µ—Ç—Ä
                        if(i===0 || i===w-1 || k===0 || k===d-1) {
                            let mat = materials.plank;
                            // –£–≥–ª—ã - –±—Ä–µ–≤–Ω–∞ (—Å—Ä—É–±)
                            if ((i===0 || i===w-1) && (k===0 || k===d-1)) mat = materials.log;
                            
                            // –û–∫–Ω–∞
                            if (j===1 && (i!==0 && i!==w-1) && (k===0 || k===d-1)) {
                                if (i===2) mat = materials.glass; 
                            }
                            
                            // –î–≤–µ—Ä—å
                            if (i===2 && j<2 && k===0) continue; // –ü—É—Å—Ç–æ—Ç–∞ –¥–ª—è –¥–≤–µ—Ä–∏

                            addBlock(x+i, y+j, z+k, mat);
                        } else if (j===0) {
                            addBlock(x+i, y+j, z+k, materials.plank); // –ü–æ–ª
                        }
                    }
                }
            }

            // –ö—Ä—ã—à–∞ (–¢—Ä–µ—É–≥–æ–ª—å–Ω–∞—è)
            for(let j=0; j<3; j++) {
                for(let k=0; k<d; k++) {
                   // –°–∫–∞—Ç—ã –∫—Ä—ã—à–∏
                   addBlock(x+j, y+h+j, z+k, materials.log);
                   addBlock(x+(w-1)-j, y+h+j, z+k, materials.log);
                   // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —Ñ—Ä–æ–Ω—Ç–æ–Ω–∞
                   if (k===0 || k===d-1) {
                        for(let fill=j; fill<w-j; fill++) {
                            addBlock(x+fill, y+h+j, z+k, materials.plank);
                        }
                   }
                }
            }
            // –ö–æ–Ω–µ–∫ –∫—Ä—ã—à–∏
            for(let k=0; k<d; k++) addBlock(x+2, y+h+2, z+k, materials.log);
        }

        function buildWell(x, y, z) {
            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ
            addBlock(x+1, y, z, materials.stone);
            addBlock(x-1, y, z, materials.stone);
            addBlock(x, y, z+1, materials.stone);
            addBlock(x, y, z-1, materials.stone);
            addBlock(x+1, y, z+1, materials.stone);
            addBlock(x-1, y, z-1, materials.stone);
            addBlock(x+1, y, z-1, materials.stone);
            addBlock(x-1, y, z+1, materials.stone);
            // –í–æ–¥–∞ –≤–Ω—É—Ç—Ä–∏
            addBlock(x, y-1, z, materials.water);
            // –ö—Ä—ã—à–∞ –∫–æ–ª–æ–¥—Ü–∞
            addBlock(x-1, y+1, z, materials.plank);
            addBlock(x-1, y+2, z, materials.plank);
            addBlock(x+1, y+1, z, materials.plank);
            addBlock(x+1, y+2, z, materials.plank);
            addBlock(x, y+3, z, materials.plank);
        }

        function buildTree(x, y, z) {
            for(let i=0; i<4; i++) addBlock(x, y+i, z, materials.log);
            for(let i=-2; i<=2; i++) {
                for(let k=-2; k<=2; k++) {
                    if (Math.abs(i)!==2 || Math.abs(k)!==2) {
                         addBlock(x+i, y+3, z+k, materials.leaves);
                         if(Math.random()>0.3) addBlock(x+i, y+4, z+k, materials.leaves);
                    }
                }
            }
            addBlock(x, y+5, z, materials.leaves);
        }

        function buildCar(x, y, z) {
            // –ö–æ–ª–µ—Å–∞
            addBlock(x-1, y, z+1, materials.carBlack);
            addBlock(x+1, y, z+1, materials.carBlack);
            addBlock(x-1, y, z-1, materials.carBlack);
            addBlock(x+1, y, z-1, materials.carBlack);
            // –ö–æ—Ä–ø—É—Å (–ñ–∏–≥—É–ª–∏)
            for(let i=-2; i<=2; i++) for(let k=-1; k<=1; k++) addBlock(x+k, y+1, z+i, materials.carRed);
            // –ö–∞–±–∏–Ω–∞
            for(let i=-1; i<=1; i++) for(let k=-1; k<=1; k++) {
                if(k===0 && i===0) addBlock(x+k, y+2, z+i, materials.carRed); // –ö—Ä—ã—à–∞
                else addBlock(x+k, y+2, z+i, materials.glass); // –°—Ç–µ–∫–ª–∞
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            if (controls.isLocked === true) {
                const delta = (time - prevTime) / 1000;
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 10.0 * delta;
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();
                if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * delta;
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);
                
                // –ö–æ–ª–ª–∏–∑–∏—è —Å –∑–µ–º–ª–µ–π
                if (controls.getObject().position.y < 2) {
                    velocity.y = 0;
                    controls.getObject().position.y = 2;
                    canJump = true;
                }
            }
            prevTime = time;
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>